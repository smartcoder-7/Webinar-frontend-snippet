# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

type AccessTokens {
  refreshToken: String!
  accessToken: String!
}

type Address {
  address1: String
  address2: String
  city: String
  province: String
  postal: String
  country: String!
}

input AddressInput {
  address1: String!
  address2: String
  city: String!
  province: String!
  postal: String!
  country: String!
}

type Analytics {
  registrationRate: RegistrationRate
  openRate: OpenRate
  attendance: Attendance
  engagement: Engagement
  chartData: [ChartPoint!]
}

type Asset {
  url: String!
  uploadUrl: String
}

type Attendance {
  ratePercent: Float
  live: AttendanceItem
  replay: AttendanceItem
}

type AttendanceCount {
  timeFrame: Float!
  joined: Float!
  left: Float!
  replayJoined: Float!
  replayLeft: Float!
}

type AttendanceItem {
  attended: Float!
  stayedToEnd: Float!
  leftEarly: Float!
  averagePercentWatched: Float!
}

type Attendee {
  id: String!
  attendeeId: AttendeeID
  visitorId: String!

  # Set the attendee registered for
  set: EWebinarSet!

  # Webinar the attendee joined and setarted watching
  ewebinar: EWebinar
  startTime: DateTime
  timezone: String!

  # DateTime when attendee joined any webinar room.
  joinTime: DateTime
  optOut: Boolean!
  firstName: String
  lastName: String
  email: String
  attendeeFields: JSON
  registeredDate: DateTime!
  watchedPercent: Float
  watchedReplayPercent: Float
  reactions: [Reaction!]
  conversation: Conversation
}

# Attendee counter option
enum AttendeeCounterOption {
  Attending
  Attended
}

type AttendeeEntity {
  id: String!
  attendeeFields: String!
  startTime: DateTime!
  timezone: String!
  email: String!
  firstName: String!
  lastName: String
}

type AttendeeID {
  visitorId: String!

  # ID of eWebinar Set
  setId: String!

  # Starttime of this attenddees webinar
  startTime: DateTime!
}

input AttendeeIDInput {
  visitorId: String!

  # ID of eWebinar Set
  setId: String!

  # Starttime of this attenddees webinar
  startTime: DateTime!
}

# Attendee reactions option
enum AttendeeReactionsOption {
  RealTimeOnly
  AllReactions
}

# The subscription billing cycles
enum BillingCycle {
  Year
  Month
}

type BlackoutPeriod {
  # Represented as (Month * 31) + Day 
  startDay: Float

  # Represented as (Month * 31) + Day 
  endDay: Float

  # Name of Holiday
  name: String
}

input BlackoutPeriodInput {
  # Name of Holiday
  name: String

  # Represented as (Month * 31) + Day 
  startDay: Float

  # Represented as (Month * 31) + Day 
  endDay: Float
}

# Change password
input ChangePasswordInput {
  token: String!
  email: String!
  password: String!
}

type ChartPoint {
  timeFrame: Float!
  liveAttendance: Float
  replayWatched: Float
  interactions: Float
  reactions: Float
}

type ChatSettings {
  # Send email to moderator 10 minutes before session starts
  emailBeforeSession: Boolean!

  # Send email to moderator when they receive chat message
  emailOnChatReceive: Boolean!

  # Private welcome message to show attendee coming into chat
  privateWelcomeMessage: String!
}

input ChatSettingsInput {
  # Send email to moderator 10 minutes before session starts
  emailBeforeSession: Boolean!

  # Send email to moderator when they receive chat message
  emailOnChatReceive: Boolean!

  # Private welcome message to show attendee coming into chat
  privateWelcomeMessage: String!
}

type Conversation {
  id: ID!
  messages: [Message!]!
  isArchived: Boolean!
  ewebinar: EWebinar!
  set: EWebinarSet!
  attendee: Attendee!

  # This conversation has transitioned to an email conversation
  inEmail: Boolean!
  lastReadAt: DateTime
  sortDate: DateTime!
  lastMessage: Message
  isAttendeeLive: Boolean!
  hasUnreadMessages: Boolean!
}

input ConversationFilters {
  type: ConversationTypeFilter!
  onlyAssigned: Boolean = false
  setId: String
  orderBy: ConversationOrderByFields
  orderDirection: OrderDirection
  cursor: String
}

# Allow orderBy fields
enum ConversationOrderByFields {
  SortDate
  LastReadAt
}

type Conversations {
  conversations: [Conversation!]!
  total: Float!
  nextCursor: String
}

enum ConversationTypeFilter {
  Inbox
  Archived
  Unread
  Live
}

# Create new ewebinar
input CreateEwebinarInput {
  title: String!
  vimeoVideoId: Float
  thumbnail: String
}

type CreateEWebinarSetInput {
  id: String
  ewebinar: EWebinar!
}

input CreateUploadUrlInput {
  scope: String!
  id: String!
  name: String!
  fileType: String
}

# Create new attendee
input CreateVisitorInput {
  setId: String!
  lastVisitedDate: DateTime
}

# Dashboard Filter Engagement
enum DashboardFilterEngagement {
  Registered
  Attended
  DidNotAttend
  LeftEarly
  WatchedUntilEnd
  Interacted
  WatchedReplay
}

# Get registrants input
input DashboardFilterInput {
  ewebinarSetId: String!
  sessionStartDate: String
  sessionEndDate: String
  engagement: DashboardFilterEngagement
}

# The javascript `Date` as string. Type represents date and time as the ISO Date string.
scalar DateTime

input EditPresenterInput {
  id: String!
  profileMediaUrl: String
  firstName: String!
  lastName: String
  email: String!
  phone: String
  company: String
  title: String
  bio: String
  socialLinks: SocialLinkInput
}

type EmailEntities {
  logoMediaUrl: String
  title: String
  content: String
  name1: String
  url1: String
  name2: String
  url2: String
  from: FromEntities
  to: ToEntities
  user: UserEntity
  team: TeamEntity
  ewebinar: EWebinarEntity
  message: MessageEntity
  messages: [MessageEntity!]
  attendee: AttendeeEntity
}

type EmailFields {
  logoMediaUrl: String
  title: String
  content: String
  name1: String
  url1: String
  name2: String
  url2: String
}

type Engagement {
  # total interactions
  totalInteractions: Float

  # total reactions
  totalReactions: Float

  # engagement percent
  engagementPercent: Float

  # chat message
  chatMessages: Float

  # questions answered
  question: Float

  # poll takens
  poll: Float

  # offer clicked
  specialOffer: Float

  # handout downloads
  handout: Float

  # contact request sent
  requestToContact: Float

  # rating given
  feedback: Float

  # tip
  tip: Float

  # private message
  privateMessage: Float

  # end stream
  endStream: Float

  # welcome
  welcome: Float

  # public Post
  publicPost: Float

  # overall rating
  overallRating: Float
}

type EWebinar {
  id: String!
  set: EWebinarSet!
  isPublished: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
  team: Team!
  title: String!
  vimeoVideoId: Float
  thumbnail: String
  primaryColor: String!
  highlightColor: String!
  font: String!
  theme: String!
  colorsMatchLogo: Boolean!
  logoMediaUrl: String
  registrationPageSettings: RegistrationPageSettings
  registrationFormSettings: RegistrationFormSettings!
  thankyouPageSettings: ThankyouPageSettings
  viewerRoomSettings: ViewerRoomSettings!
  exitRoomSettings: ExitRoomSettings!

  # Waiting room duration in seconds
  waitingRoomDurationSecs: Float!

  # Exit room duration in seconds
  exitRoomDurationSecs: Float!
  oneTimeEvent: Boolean!
  timeZone: String!
  use24HourClock: Boolean!
  startDate: DateTime
  endDateEnabled: Boolean
  endDate: DateTime
  justInTimeModeEnabled: Boolean!
  scheduleSettings: ScheduleSettings
  presenters: [Presenter!]
  notificationSettings: NotificationSettings
  enableChat: Boolean!
  chatSettings: ChatSettings
  uploadStatus: UploadStatus
  duration: Float
  notifications: [Notification!]!
  attendees: [Attendee!]
  conversations: [Conversation!]
  interactions: [Interaction!]!
  reactions: [Reaction!]
  unreadConversationsCount: Float!
}

type EWebinarEntity {
  id: String!
  title: String!
  scheduleSettings: ScheduleSettings!
}

input EwebinarSessionsInput {
  ewebinarSetId: String!
  clientTimeZone: String!
}

type EwebinarSessionsPayload {
  sessions: [Session!]!
  timeZone: String!
}

type EWebinarSet {
  id: String!
  team: Team!
  ewebinars: [EWebinar!]!
  reactions: [Reaction!]!
  draftWebinar: EWebinar!
  publicWebinar: EWebinar
  moderator: User
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime!
  attendees: [Attendee!]!
  conversations: [Conversation!]!
  isPublishable: Boolean!
}

type ExitRoomSettings {
  showReplayLink: Boolean
  redirectAfterExit: Boolean
  redirectLink: String
}

input ExitRoomSettingsInput {
  showReplayLink: Boolean = true
  redirectAfterExit: Boolean = false
  redirectLink: String
}

type FeedbackDetailsFields {
  answer: String
}

# Create reaction details
input FeedbackDetailsFieldsInput {
  answer: String
}

type FromEntities {
  name: String
  email: String
}

# Get registrants input
input GetRegistrantsInput {
  ewebinarSetId: String!
  sessionStartDate: String
  sessionEndDate: String
  engagement: DashboardFilterEngagement
  orderBy: GetRegistrantsOrderBy
  orderDirection: OrderDirection
  interactionId: String
  nextCursor: String
}

# Get Registrants Order By
enum GetRegistrantsOrderBy {
  FirstName
  LastName
  Email
  RegisteredDate
  StartTime
  WatchedPercent
  WatchedReplayPercent
  PollAnswer
  FeedbackRating
}

type Interaction {
  id: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  ewebinar: EWebinar!
  type: InteractionType!
  room: RoomType!
  appearAt: Float!
  details: InteractionDetailFields
  reactions: [Reaction!]
  pollResult: ReactionResult
  feedbackResult: ReactionResult
  reaction(attendeeId: String!): Reaction
}

type InteractionDetailFields {
  imageMediaUrl: String

  # Question or title
  title: String!

  # Description or chat message body
  description: String
  buttonText: String
  resultsAppearAt: Float
  answer1: String
  answer2: String
  answer3: String
  answer4: String
  downloadLink: String
  offerLink: String
  offerEndsIn: Float
}

# Update interaction details
input InteractionDetailsInput {
  imageMediaUrl: String

  # Question or title
  title: String!

  # Description or chat message body
  description: String
  buttonText: String
  resultsAppearAt: Float
  answer1: String
  answer2: String
  answer3: String
  answer4: String
  downloadLink: String
  offerLink: String
  offerEndsIn: Float
}

# Update interaction
input InteractionInput {
  id: String
  ewebinarId: String
  type: String!
  room: RoomType!
  appearAt: Float!
  details: InteractionDetailsInput
}

# Interaction type
enum InteractionType {
  Welcome
  Feedback
  Handout
  Poll
  PublicPost
  PrivateMessage
  Question
  RequestToContact
  SpecialOffer
  Tip
  EndStream
}

# The invite status
enum InvitationStatus {
  Pending
  Accepted
  Rejected
}

# The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
scalar JSON

type JustInTimeHoursOfOperation {
  day: WeekDays!
  times: [Float!]!
}

input JustInTimeHoursOfOperationInput {
  day: WeekDays!
  times: [Float!]!
}

type LatestNotificationTimestamp {
  id: String!
}

type Me {
  id: String!
  teamRelations: [TeamUserRelation!]!
  currentTeamRelation: TeamUserRelation
  team: Team!
  presenter: Presenter!

  # Webinars I've been assigned to as moderator
  assignedSets: [EWebinar!]
  version: Float!
  createdAt: DateTime!
  updatedAt: DateTime!
  profileMediaUrl: String
  email: String!
  firstName: String!
  lastName: String

  # First + Last name
  name: String!
  timezone: String!
  password: String
  state: UserState!
  isVerified: Boolean
  tokens: AccessTokens!
}

type Message {
  id: ID!
  conversation: Conversation!
  user: User
  set: EWebinarSet!
  fromAttendee: Boolean!
  roomType: String!
  timeInRoomSecs: Float!
  timeSent: DateTime!
  content: String!
  type: MessageType!
  createdAt: DateTime!
  updatedAt: DateTime!
  lastMessage: Message
}

type MessageEntity {
  id: String!
  fromAttendee: Boolean!
  content: String!
  timeSent: DateTime!
}

input MessageInput {
  # Conversation contains all info needed to add message
  conversationId: String

  # Fields necessary to identify fully an attendee.  Must be present if no conversationId present
  attendeeId: AttendeeIDInput

  # Moderator user ID - NULL if message is from Attendee
  userId: String
  fromAttendee: Boolean!

  # Unix timestamp which we can compare to startTime of ewebinar to determine time in room
  timeSent: DateTime!

  # Number of seconds into presentation taking starting from 0 at beginning of
  # waiting room.  Note for replays this values starts at waitingRoomDurationSecs
  # and the value would exclude any time the video has been paused
  timeInWebinarSecs: Float

  # Message content
  content: String!

  # Type of message sent via socket
  type: String!
}

input MessagePost {
  chat: MessageInput
  token: String
  attendee: AttendeeIDInput
}

# Type of message sent via socket
enum MessageType {
  Interaction
  Typing
  Chat
}

type Mutation {
  archiveConversation(id: String!): String!
  seenConversation(id: String!): Conversation!
  registerAttendee(data: RegisterAttendeeInput!): Attendee
  updateStartTime(id: String!, startTime: DateTime!): Attendee
  createVisitor(data: CreateVisitorInput!): Attendee
  attendeeOptOut(optOut: Boolean!, id: String!): Attendee!
  attendeeJoinWebinar(joinTime: DateTime!, id: String!): Attendee!
  createInteraction(data: InteractionInput!): Interaction
  updateInteraction(data: InteractionInput!): Interaction!
  deleteInteraction(id: String!): Boolean!
  createNotification(data: NotificationInput!): Notification
  updateLatestTimestamp(timestamp: DateTime!): DateTime!
  updateNotification(data: NotificationInput!): Notification!
  deleteNotification(id: String!): Boolean!
  login(password: String!, email: String!): Me!
  logout: Boolean
  registerUserAndTeam(data: NewUserAndTeamInput!): Me!
  registerUserInTeam(data: RegisterUserAndTeamInput!, team: String!): Me!
  verifyToken(token: String!): Me!
  skipVerifyEmail: User!
  resendConfirmationEmail: String!
  resetPassword(email: String!): String!
  changePassword(data: ChangePasswordInput!): Me!
  acceptInvitation(token: String!): Me!
  rejectInvitation(token: String!): Boolean!
  scrapeVideoMetaFromURL(url: String!): VideoMeta
  uploadVideo(data: UploadVideoInput!, id: String!): String!
  startVideoUpload(fileName: String!, fileSize: Float!): StartVideoUploadInfo!
  setLocalVimeoUploadDone(data: SetLocalVimeoUploadDoneInput!, id: String!): EWebinar!
  createVimeoUploadUrl(data: CreateUploadUrlInput!): Asset!
  createUploadUrl(data: CreateUploadUrlInput!): Asset!
  createEwebinar(data: CreateEwebinarInput!): EWebinar
  updateEwebinar(data: UpdateEwebinarInput!): EWebinar!
  deleteEwebinar(id: String!): String!
  publishEwebinar(setId: String!): Boolean!
  unpublishEwebinar(id: String!): EWebinar!
  duplicateEwebinar(setId: String!): EWebinar!
  deleteSet(id: String!): EWebinarSet!
  updateMe(data: UpdateUserAndTeamInput!): Me!
  addPresenter(data: EditPresenterInput!): Presenter!
  updatePresenter(data: EditPresenterInput!): Presenter!
  removePresenter(id: String!): Boolean!
  addUser(data: UserAndPresenterInput!): Team!
  removeUser(replacementId: String!, id: String!): Team!
  updateUser(data: UserAndPresenterInput!): Team
  resendInvitationEmail(teamId: String!, userId: String!): String!
  createReaction(data: ReactionInput!): Reaction
}

# Create new user & new team
input NewUserAndTeamInput {
  profileMediaUrl: String
  firstName: String!
  lastName: String!
  email: String!
  role: UserRole
  password: String
  team: TeamInput!
}

input NewUserInput {
  profileMediaUrl: String
  firstName: String!
  lastName: String!
  email: String!
  role: UserRole
  password: String
}

type Notification {
  id: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  ewebinar: EWebinar!
  type: NotificationType!

  # Network to send notification by
  sendBy: SendBy!

  # Number of Minutes to offset notification by
  offsetSeconds: Float!
  whenNumber: Float!
  whenUnit: WhenUnit!
  subject: String!
  message: String!

  # Which group of attendees to send the notification to.  (Only for follow ups)
  followUpTo: SendTo
}

type NotificationForAttendee {
  id: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  ewebinar: EWebinar!
  type: NotificationType!

  # Network to send notification by
  sendBy: SendBy!

  # Number of Minutes to offset notification by
  offsetSeconds: Float!
  whenNumber: Float!
  whenUnit: WhenUnit!
  subject: String!
  message: String!

  # Which group of attendees to send the notification to.  (Only for follow ups)
  followUpTo: SendTo
  attendee: Attendee!
}

# Create new notification
input NotificationInput {
  id: String
  ewebinarId: String!
  type: String!
  sendBy: String!
  whenNumber: Float!
  whenUnit: WhenUnit!
  followUpTo: SendTo
  subject: String!
  message: String!
}

type NotificationsAndTime {
  notifications: [NotificationForAttendee!]!
  currentTimestamp: DateTime!
}

type NotificationSettings {
  # Name to send notifications from
  fromName: String!

  # Email to send notifications from
  fromEmail: String!
}

input NotificationSettingsInput {
  # Name to send notifications from
  fromName: String

  # Email to send notifications from
  fromEmail: String
}

# Type of notification
enum NotificationType {
  Confirmation
  Reminder
  FollowUp
}

type OpenRate {
  ratePercent: Float
  notificationSent: Float
  notificationOpened: Float
}

# Query Order Direction
enum OrderDirection {
  Asc
  Desc
}

type PollDetailsFields {
  answer: String
}

# Create reaction details
input PollDetailsFieldsInput {
  answer: String
}

type Presenter {
  id: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  user: User
  team: Team!
  isActive: Boolean!
  profileMediaUrl: String
  firstName: String!
  lastName: String

  # First + Last name
  name: String!
  email: String
  phone: String
  company: String
  title: String
  bio: String
  socialLinks: SocialLink
}

input PresenterFilters {
  orderBy: PresenterOrderByFields
  orderDirection: OrderDirection
}

type PresenterInput {
  id: String!
  user: User!
  isActive: Boolean!
  profileMediaUrl: String
  firstName: String!
  lastName: String!
  email: String
  phone: String
  company: String
  title: String
  bio: String
  socialLinks: SocialLink
}

# Allow orderBy fields
enum PresenterOrderByFields {
  CreatedAt
  FirstName
}

type PublicInvitedUser {
  id: String!
  firstName: String!
  lastName: String
  role: UserRole
  teamId: String!
  invitedByUser: PublicInviter
}

type PublicInviter {
  id: String!
  profileMediaUrl: String
  firstName: String!
  lastName: String
}

type QMessage {
  q: String
  receiptHandle: String
  upload: UploadMessage
  transcode: TranscodeMessage
  sendSms: SendSmsMessage
  sendEmail: SendEmailMessage
  sendNotification: SendNotificationMessage
  processNotifications: String
}

type Query {
  conversationForAttendee(attendeeId: AttendeeIDInput!): Conversation!
  conversation(id: String!): Conversation!
  conversations(filters: ConversationFilters!): Conversations!
  attendee(id: String!): Attendee!
  registrants(filter: GetRegistrantsInput!): Registrants!
  interactions(ewebinarId: String!): [Interaction!]!
  interaction(id: String!): Interaction!
  notifications(ewebinarId: String!): [Notification!]!
  overdueNotifications: NotificationsAndTime!
  user(id: String!): User!
  users(filters: UserFilters!): [User!]!
  isEmailAlreadyExist(email: String!): Boolean!
  checkEmptyPassword: Boolean!
  ewebinar(id: String!): EWebinar
  set(id: String!): EWebinarSet
  sets: [EWebinarSet!]!
  publicSet(id: String!): EWebinarSet!
  publicSets(teamId: String!): [EWebinarSet!]!
  analytics(filter: DashboardFilterInput): Analytics
  me: Me
  presenter(id: String!): Presenter!
  presenters: [Presenter!]!
  myTeam: Team!
  team(id: String!): Team!
  teams: [Team!]!
  teamForSubdomain(subdomain: String!): Team!
  teamUsers(filters: UserFilters!): [UserInTeam!]!
  messages(conversationId: String!): [Message!]!
  reactionResults(to: String!, from: String!, ewebinarSetId: String!): [ReactionResult!]!
  ewebinarSession(data: EwebinarSessionsInput!): EwebinarSessionsPayload
}

type QuestionDetailsFields {
  answer: String
}

# Create reaction details
input QuestionDetailsFieldsInput {
  answer: String
}

type Reaction {
  id: String!
  interaction: Interaction
  ewebinar: EWebinar!
  ewebinarSet: EWebinarSet!
  attendee: Attendee!
  eventName: ReactionEventName!
  detailsFields: ReactionDetailFields!
  reactionAppearAt: Float!
  interactionType: InteractionType
  reactionAppearRoom: RoomType!
  connectionId: String
  createdAt: DateTime!
  updatedAt: DateTime!
  pollAnswer: String
  feedbackRating: Float
}

type ReactionDetailFields {
  feedback: FeedbackDetailsFields
  poll: PollDetailsFields
  question: QuestionDetailsFields
  requestToContact: RequestToContactDetailsFields
}

# Create reaction details
input ReactionDetailFieldsInput {
  feedback: FeedbackDetailsFieldsInput
  poll: PollDetailsFieldsInput
  question: QuestionDetailsFieldsInput
  requestToContact: RequestToContactDetailsFieldsInput
}

# Reaction Event Name
enum ReactionEventName {
  ReplayJoined
  ReplayLeft
  Joined
  Left
  Like
  Love
  RatingGiven
  Interacted
}

type ReactionForAttendee {
  id: String!
  attendeeId: AttendeeID
  visitorId: String!

  # Set the attendee registered for
  set: EWebinarSet!

  # Webinar the attendee joined and setarted watching
  ewebinar: EWebinar
  startTime: DateTime
  timezone: String!

  # DateTime when attendee joined any webinar room.
  joinTime: DateTime
  optOut: Boolean!
  firstName: String
  lastName: String
  email: String
  attendeeFields: JSON
  registeredDate: DateTime!
  watchedPercent: Float
  watchedReplayPercent: Float
  reactions: [Reaction!]
  conversation: Conversation
  reaction: Reaction
}

# Update reaction
input ReactionInput {
  id: String
  interactionId: String
  ewebinarId: String!
  eventName: ReactionEventName!
  detailsFields: ReactionDetailFieldsInput
  reactionAppearAt: Float!
  interactionType: InteractionType!
  reactionAppearRoom: RoomType!
  startTime: DateTime
  pollAnswer: String
  feedbackRating: Float
  attendeeId: String!
}

type ReactionResult {
  totalCount: Float
  interaction: Interaction!
  respondants: Float
  detailsFields: ReactionResultDetails
}

type ReactionResultDetailField {
  count: Float
  percent: Float
}

type ReactionResultDetails {
  answer1: ReactionResultDetailField
  answer2: ReactionResultDetailField
  answer3: ReactionResultDetailField
  answer4: ReactionResultDetailField
  feedbackRating: Float
}

# Create new attendee
input RegisterAttendeeInput {
  setId: String!
  startTime: DateTime!
  startTimeTimeZone: String
  attendeeFields: JSON
  firstName: String
  lastName: String
  email: String
  lastVisitedDate: DateTime
  timezone: String!
  optOut: Boolean = false
}

input RegisterUserAndTeamInput {
  profileMediaUrl: String
  firstName: String!
  lastName: String!
  email: String!
  role: UserRole
  password: String
  team: TeamInput!
}

type Registrants {
  attendees: [ReactionForAttendee!]!
  total: Float!
  nextCursor: String
}

type RegistrationFooter {
  tagline: String
  disclaimer: String
}

input RegistrationFooterInput {
  tagline: String
  disclaimer: String
}

type RegistrationFormField {
  fieldId: Float!
  fieldName: String!
  fieldType: String!
  isRequired: Boolean!
  order: Float!
  isRemovable: Boolean
}

input RegistrationFormFieldInput {
  fieldId: Float!
  fieldName: String!
  fieldType: String!
  isRequired: Boolean!
  order: Float!
  isRemovable: Boolean!
}

type RegistrationFormSettings {
  # Title of form
  title: String!
  fields: [RegistrationFormField!]!

  # Show consent checkbox text
  showConsentCheckbox: Boolean!

  # Consent checkbox text
  consentCheckboxText: String!

  # Register button text
  registerButton: String!
}

input RegistrationFormSettingsInput {
  # Title of form
  title: String!
  fields: [RegistrationFormFieldInput!]!

  # Show consent checkbox text
  showConsentCheckbox: Boolean!

  # Consent checkbox text
  consentCheckboxText: String!

  # Register button text
  registerButton: String!
}

type RegistrationPageContacts {
  active: Boolean
  title: String
  subtitle: String
  ctaBtnText: String
}

input RegistrationPageContactsInput {
  active: Boolean = true
  title: String
  subtitle: String
  ctaBtnText: String
}

type RegistrationPageDescriptionBlock {
  active: Boolean
  mainMediaUrl: String
  title: String
  description: String
}

input RegistrationPageDescriptionBlockInput {
  active: Boolean = true
  mainMediaUrl: String
  title: String
  description: String
}

type RegistrationPageHeader {
  title: String
  subtitle: String
  teaserText: String
  ctaTopBtnText: String
  ctaBtnText: String
  mainMediaUrl: String
}

input RegistrationPageHeaderInput {
  title: String
  subtitle: String
  teaserText: String
  ctaBtnText: String
  ctaTopBtnText: String
  mainMediaUrl: String
}

type RegistrationPageReason {
  content: String
}

input RegistrationPageReasonInput {
  content: String
}

type RegistrationPageReasons {
  active: Boolean
  title: String
  reasons: [RegistrationPageReason!]
  mainMediaUrl: String
}

input RegistrationPageReasonsInput {
  active: Boolean = true
  title: String
  reasons: [RegistrationPageReasonInput!]
  mainMediaUrl: String
}

type RegistrationPageSettings {
  headerSection: RegistrationPageHeader
  presentersSection: RegistrationPresenters
  descriptionBlockSection: RegistrationPageDescriptionBlock
  reasonsSection: RegistrationPageReasons
  testimonialsSection: RegistrationPageTestimonials
  contactSection: RegistrationPageContacts
  footerSection: RegistrationFooter
}

input RegistrationPageSettingsInput {
  headerSection: RegistrationPageHeaderInput
  presentersSection: RegistrationPresentersInput
  descriptionBlockSection: RegistrationPageDescriptionBlockInput
  reasonsSection: RegistrationPageReasonsInput
  testimonialsSection: RegistrationPageTestimonialsInput
  contactSection: RegistrationPageContactsInput
  footerSection: RegistrationFooterInput
}

type RegistrationPageTestimonial {
  avatarMediaUrl: String
  name: String
  description: String
  position: String
}

input RegistrationPageTestimonialInput {
  avatarMediaUrl: String
  name: String
  description: String
  position: String
}

type RegistrationPageTestimonials {
  active: Boolean
  headerOne: String
  testimonials: [RegistrationPageTestimonial!]
  headerTwo: String
  logos: [RegistrationPageTestimonialsLogo!]
}

input RegistrationPageTestimonialsInput {
  active: Boolean = true
  headerOne: String
  testimonials: [RegistrationPageTestimonialInput!]
  headerTwo: String
  logos: [RegistrationPageTestimonialsLogoInput!]
}

type RegistrationPageTestimonialsLogo {
  logoMediaUrl: String
}

input RegistrationPageTestimonialsLogoInput {
  logoMediaUrl: String
}

type RegistrationPresenter {
  avatarMediaUrl: String
  name: String
  description: String
}

input RegistrationPresenterInput {
  avatarMediaUrl: String
  name: String
  description: String
}

type RegistrationPresenters {
  active: Boolean
  title: String
  presenters: [RegistrationPresenter!]
}

input RegistrationPresentersInput {
  active: Boolean = true
  title: String
  presenters: [RegistrationPresenterInput!]
}

type RegistrationRate {
  ratePercent: Float
  uniqueVisitors: Float
  registered: Float
}

type RequestToContactDetailsFields {
  phone: String
  email: String
  contactTime: String
}

# Create reaction details
input RequestToContactDetailsFieldsInput {
  phone: String
  email: String
  contactTime: String
}

# Room type
enum RoomType {
  Waiting
  Presentation
  Exit
}

type ScheduleSettings {
  # Array of 7 booleans for [Mon,...,Sun]
  onWeekDays: [Boolean!]

  # When throughout the day to have sessions in minutes from 0 (Midnight)
  atMinutes: [Float!]

  # Number of sessions to show in the dropdown - replay session and just in time session
  numberOfSessions: Float

  # Shows Replay as one of sessions to user
  showReplaySession: Boolean

  # How often to have in Minutes: 15, 30, 60
  justInTimeIntervalMinutes: Float

  # Array of [start time, end time] in minutes from midnight
  justInTimeHoursOfOperations: [JustInTimeHoursOfOperation!]

  # Array of 7 booleans for [Mon,...,Sun]
  justInTimeWeekDays: [Boolean!]
  blackoutPeriods: [BlackoutPeriod!]
}

input ScheduleSettingsInput {
  # Array of 7 booleans for [Mon,...,Sun]
  onWeekDays: [Boolean!]

  # When throughout the day to have sessions in minutes from 0 (Midnight)
  atMinutes: [Float!]

  # Number of sessions to show in the dropdown - replay session and just in time session
  numberOfSessions: Float = 3

  # Shows Replay as one of sessions to user
  showReplaySession: Boolean = false

  # How often to have in Minutes: 15, 30, 60
  justInTimeIntervalMinutes: Float

  # Array of [start time, end time] in minutes from midnight
  justInTimeHoursOfOperations: [JustInTimeHoursOfOperationInput!]

  # Array of 7 booleans for [Mon,...,Sun]
  justInTimeWeekDays: [Boolean!]
  blackoutPeriods: [BlackoutPeriodInput!]
}

# network of notification
enum SendBy {
  Email
  Sms
}

type SendEmailMessage {
  template: String!
  fields: EmailFields!
  entities: EmailEntities!
  sendTime: DateTime!
}

type SendNotificationMessage {
  notification: NotificationForAttendee!
  sendTime: DateTime!
}

type SendSmsMessage {
  phoneNumber: String!
  message: String!
  notificationId: String!
  attendeeId: String!
}

# Send notification up to
enum SendTo {
  AllAttendees
  DidNotAttend
  LeftEarly
  WatchedUntilEnd
}

type Session {
  value: String!
  text: String!
}

# Vimeo Video Url & ID
input SetLocalVimeoUploadDoneInput {
  vimeoVideoUri: String!
  vimeoVideoId: Float!
}

type SocialLink {
  facebook: String
  twitter: String
  linkedin: String
}

input SocialLinkInput {
  facebook: String
  twitter: String
  linkedin: String
}

type SocketAttendeeResponse {
  id: String!
  firstName: String!
  lastName: String
}

type SocketChatResponse {
  hasUnreadMessages: Boolean!
  message: SocketMessageResponse
  typing: SocketTypingResponse
  conversation: SocketConversationResponse!
  user: SocketUserResponse!
  attendee: SocketAttendeeResponse
}

type SocketConversationResponse {
  id: ID!
  isArchived: Boolean!
  inEmail: Boolean!
  lastReadAt: DateTime!
  sortDate: DateTime!
  isAttendeeLive: Boolean!
}

input SocketMessage {
  connectionId: String
  post: MessagePost
}

type SocketMessageResponse {
  id: ID!
  fromAttendee: Boolean!
  roomType: String!
  timeInRoomSecs: Float!
  timeSent: DateTime!
  content: String!
  type: String!
}

type SocketTypingResponse {
  fromAttendee: Boolean!
  timeSent: DateTime!
}

type SocketUserResponse {
  id: String!
  profileMediaUrl: String
  firstName: String!
  lastName: String
}

type StartVideoUploadInfo {
  uploadLink: String!
  videoUri: String!
}

type Team {
  id: String!
  ewebinars: [EWebinar!]!

  # Team or Company Name
  name: String
  subdomain: String
  logoMediaUrl: String
  users: [TeamUserRelation!]!
  sets: [EWebinarSet!]!
  stripeCustomerId: String

  # Subscription ID on Stripe.  Grab "plan" to show user from there.
  stripeSubscriptionId: String!

  # Minimum number of webinars to charge for - Enterprise plans for example
  minimumPublicWebinars: Float!
  address: Address!
  billingCycle: BillingCycle!

  # Last 4 digits of CC used to subscribe
  last4: String

  # CC type
  ccType: String
  presenters: [Presenter!]!
}

type TeamEntity {
  id: String!
  name: String!
  cc: String!
}

input TeamInput {
  id: String

  # Team or Company Name
  name: String
  subdomain: String
  logoMediaUrl: String
  address: AddressInput
  billingCycle: BillingCycle
  stripeCustomerId: String

  # Last 4 digits of CC used to subscribe
  last4: String

  # CC Type
  ccType: String

  # Payment Method ID generated by Stipe JS Library
  paymentMethodID: String
}

type TeamUserRelation {
  id: ID!
  team: Team!
  user: User!
  invitedByUser: User
  role: String!
  invitationStatus: InvitationStatus
}

type ThankyouPageHeader {
  title: String
  subtitle: String
  sessionId: Float
  mainMediaUrl: String
}

input ThankyouPageHeaderInput {
  logoUrl: String
  title: String
  subtitle: String
  sessionId: Float
  mainMediaUrl: String
  redirectionUrl: String
}

type ThankyouPageSettings {
  redirectionUrl: String
  headerSection: ThankyouPageHeader
  presentersSection: RegistrationPresenters
  shareSection: ThankyouPageShare
  footerSection: RegistrationFooter
}

input ThankyouPageSettingsInput {
  redirectionUrl: String
  headerSection: ThankyouPageHeaderInput
  presentersSection: RegistrationPresentersInput
  shareSection: ThankyouPageShareInput
  footerSection: RegistrationFooterInput
}

type ThankyouPageShare {
  active: Boolean
  title: String
  socialMedia: [ThankyouPageShareSocial!]
}

input ThankyouPageShareInput {
  active: Boolean = true
  title: String
  socialMedia: [ThankyouPageShareSocialInput!]
}

type ThankyouPageShareSocial {
  name: String
  url: String
}

input ThankyouPageShareSocialInput {
  name: String
  url: String
}

type ToEntities {
  firstName: String
  lastName: String
  name: String
}

type Token {
  id: String!
}

type TranscodeMessage {
  webinarId: String!
  videoUrl: String!
  accessToken: String!
  progress: Float!
}

# Update conversation
input UpdateConversationInput {
  id: String!
  isArchived: Boolean
  lastReadAt: DateTime
}

# Update ewebinar
input UpdateEwebinarInput {
  id: String!
  title: String
  vimeoVideoId: Float
  thumbnail: String
  primaryColor: String
  highlightColor: String
  font: String
  theme: String
  colorsMatchLogo: Boolean
  logoMediaUrl: String
  registrationPageSettings: RegistrationPageSettingsInput
  registrationFormSettings: RegistrationFormSettingsInput
  thankyouPageSettings: ThankyouPageSettingsInput
  viewerRoomSettings: ViewerRoomSettingsInput
  exitRoomSettings: ExitRoomSettingsInput

  # Waiting room duration in seconds
  waitingRoomDurationSecs: Float

  # Exit room duration in seconds
  exitRoomDurationSecs: Float
  oneTimeEvent: Boolean
  timeZone: String
  use24HourClock: Boolean
  startDate: DateTime
  endDateEnabled: Boolean = false
  endDate: DateTime
  justInTimeModeEnabled: Boolean
  scheduleSettings: ScheduleSettingsInput
  notificationSettings: NotificationSettingsInput
  enableChat: Boolean
  chatSettings: ChatSettingsInput
  duration: Float
  uploadStatus: UploadStatusInput
  set: UpdateEWebinarSetInput
  presenterIds: [String!]
}

input UpdateEWebinarSetInput {
  id: String!
  moderator: UpdateModeratorInput!
}

input UpdateModeratorInput {
  id: String!
}

# Update user or me
input UpdateUserAndTeamInput {
  id: String
  profileMediaUrl: String
  firstName: String
  lastName: String
  timezone: String
  role: String
  team: TeamInput
  email: String!
  password: String
}

type UploadMessage {
  webinarId: String!
  url: String!
  accessToken: String!
}

type UploadStatus {
  stage: String
  localUpload: Boolean
  progress: Float
  done: Boolean
  error: String
}

input UploadStatusInput {
  stage: String
  localUpload: Boolean
  progress: Float
  done: Boolean
  error: String
}

# VimeoUrl
input UploadVideoInput {
  url: String!
}

type User {
  id: String!
  teamRelations: [TeamUserRelation!]!
  currentTeamRelation: TeamUserRelation
  team: Team!
  presenter: Presenter!

  # Webinars I've been assigned to as moderator
  assignedSets: [EWebinar!]
  version: Float!
  createdAt: DateTime!
  updatedAt: DateTime!
  profileMediaUrl: String
  email: String!
  firstName: String!
  lastName: String

  # First + Last name
  name: String!
  timezone: String!
  password: String
  state: UserState!
  isVerified: Boolean
}

# Update User input
input UserAndPresenterInput {
  profileMediaUrl: String
  firstName: String!
  lastName: String!
  email: String!
  role: UserRole
  id: String
  phone: String
  company: String
  title: String
  bio: String
  socialLinks: SocialLinkInput
  presenterId: String
}

type UserEntity {
  id: String!
  firstName: String!
  lastName: String!
  email: String!
  timezone: String!
  role: UserRole!
}

input UserFilters {
  orderBy: UserOrderByFields
  orderDirection: OrderDirection
}

input UserInput {
  profileMediaUrl: String
  firstName: String!
  lastName: String!
  email: String!
  role: UserRole
}

type UserInTeam {
  id: String!
  teamRelations: [TeamUserRelation!]!
  currentTeamRelation: TeamUserRelation
  team: Team!
  presenter: Presenter!

  # Webinars I've been assigned to as moderator
  assignedSets: [EWebinar!]
  version: Float!
  createdAt: DateTime!
  updatedAt: DateTime!
  profileMediaUrl: String
  email: String!
  firstName: String!
  lastName: String

  # First + Last name
  name: String!
  timezone: String!
  password: String
  state: UserState!
  isVerified: Boolean
  role: UserRole!
  invitationStatus: InvitationStatus
}

# Allow orderBy fields
enum UserOrderByFields {
  CreatedAt
  FirstName
}

# User Authorization Roles
enum UserRole {
  Ops
  Admin
  Creator
  Moderator
}

enum UserState {
  New
  HasCreated
  HasPublished
}

type VideoMeta {
  id: String!
  url: String!
  title: String!
  duration: String!
  thumbnail: String!
}

type ViewerRoomSettings {
  attendeeCounter: Boolean
  attendeeCounterOption: AttendeeCounterOption
  attendeeReactions: Boolean
  attendeeReactionsOption: AttendeeReactionsOption
}

input ViewerRoomSettingsInput {
  attendeeCounter: Boolean = true
  attendeeCounterOption: AttendeeCounterOption = Attended
  attendeeReactions: Boolean = true
  attendeeReactionsOption: AttendeeReactionsOption = AllReactions
}

# days of week
enum WeekDays {
  mon
  tue
  wed
  thu
  fri
  sat
  sun
}

type WelcomeMessageAttendeeVariables {
  firstName: String!
  lastName: String!
  name: String!
}

type WelcomeMessageVariables {
  firstName: String!
  lastName: String!
  name: String!
  attendee: JSON!
}

# When units
enum WhenUnit {
  Minutes
  Hours
  Days
}
